/*
	jsFacial
	2.1

	Judd Simantov
		judd@cgmuscle.com
		www.cgmuscle.com
	Edited by Bohdon Sayre
		bsayre@c.ringling.edu

	unique prefix: jsfw (not completely enforced

	Description:
		Provides a GUI for hooking up blendshape controls
		in the style of Jason Osipa.

	Version 2.1:
		> Brought back the 50/50 control by request
		> Attempted to do some cleaning.. not too much accomplished...
		> Redesigned the interface, do to small glitches in 2009
		> No major functionality changed
		

	Feel free to email me with any bugs, comments, or requests!
*/
global proc jsFacial() {
	//we want a global string to remember the last created ctl name
	//this helps us reduce duplicate typing :D
	global string $jsfWinLastCtlName;
	global int $jsTypeFActive;
	global int $jsTypeD50Active;
	
	
	//window name
	$win = "jsFacialWin";
	
	//check for pre-existing window
	if (`window -ex $win`) deleteUI -wnd $win;
	
	//create window
	window -rtf 1 -mb 1 -mxb 0 -t "jsFacial 2.1" -mnc ("window -e -t \"jsFacial 2.1\" "+$win+";") $win;
	
	
	//main layout
	int $btnSize = 40;
	int $btnOff = -$btnSize * 0.5;
	vector $btnCol = <<.74, .87, .97>>;
	
	formLayout -nd 100 jsfWinMainForm;
	
		//New Control Frame
		frameLayout -li 6 -l "Create New Control" -la "center" -cll 1 -cl 0 -mh 4 -bs "etchedIn" jsfWinBtnGridFrame;
			formLayout -nd 100 jsfWinBtnGridForm;
				$btn1 = `iconTextButton -c "jsCreateControl(\"jsCreateTypeCControl\")" -ann "Create an all-directional control" -st "iconOnly" -image1 "jsFacial\\jsFacial_8.bmp" -hi "jsFacial\\jsFacial_8_hi.bmp" -w $btnSize -h $btnSize`;
				$btn2 = `iconTextButton -c "global int $jsTypeD50Active; $jsTypeD50Active = 0; jsCreateControl(\"jsCreateTypeDControl\")" -ann "Create a 5-point control" -st "iconOnly" -image1 "jsFacial\\jsFacial_5.bmp" -hi "jsFacial\\jsFacial_5_hi.bmp" -w $btnSize -h $btnSize`;
				$btn3 = `iconTextButton -c "global int $jsTypeD50Active; $jsTypeD50Active = 1; jsCreateControl(\"jsCreateTypeDControl\")" -ann "Create a 50/50 control" -st "iconOnly" -image1 "jsFacial\\jsFacial_5-2.bmp" -hi "jsFacial\\jsFacial_5-2_hi.bmp" -w $btnSize -h $btnSize`;
				$btn4 = `iconTextButton -c "jsCreateControl(\"jsCreateTypeEControl\")" -ann "Create a 3-point control" -st "iconOnly" -image1 "jsFacial\\jsFacial_3.bmp" -hi "jsFacial\\jsFacial_3_hi.bmp" -w $btnSize -h $btnSize`;
				$btn5 = `iconTextButton -c "global int $jsTypeFActive; $jsTypeFActive = 0; jsCreateControl(\"jsCreateTypeAControl\")" -ann "Create a 2-point vertical control" -st "iconOnly" -image1 "jsFacial\\jsFacial_2vert.bmp" -hi "jsFacial\\jsFacial_2vert_hi.bmp" -w $btnSize -h $btnSize`;
				$btn6 = `iconTextButton -c "global int $jsTypeFActive; $jsTypeFActive = 0; jsCreateControl(\"jsCreateTypeBControl\")" -ann "Create a 2-point horizontal control" -st "iconOnly" -image1 "jsFacial\\jsFacial_2horz.bmp" -hi "jsFacial\\jsFacial_2horz_hi.bmp" -w $btnSize -h $btnSize`;
				$btn7 = `iconTextButton -c "global int $jsTypeFActive; $jsTypeFActive = 1; jsCreateControl(\"jsCreateTypeAControl\");" -ann "Create a 1-point vertical control" -st "iconOnly" -image1 "jsFacial\\jsFacial_1vert.bmp" -hi "jsFacial\\jsFacial_1vert_hi.bmp" -w $btnSize -h $btnSize`;
				$btn8 = `iconTextButton -c "global int $jsTypeFActive; $jsTypeFActive = 1; jsCreateControl(\"jsCreateTypeBControl\");" -ann "Create a 1-point horizontal control" -st "iconOnly" -image1 "jsFacial\\jsFacial_1horz.bmp" -hi "jsFacial\\jsFacial_1horz_hi.bmp" -w $btnSize -h $btnSize`;

				setParent ..;
			formLayout -e
				-ap $btn1 "left" $btnOff 6 -ap $btn2 "left" $btnOff 18 -ap $btn3 "left" $btnOff 30 -ap $btn4 "left" $btnOff 42
				-ap $btn5 "left" $btnOff 54 -ap $btn6 "left" $btnOff 66 -ap $btn7 "left" $btnOff 78 -ap $btn8 "left" $btnOff 90
				jsfWinBtnGridForm;
			setParent..;
		
		//Setup Connections Frame
		frameLayout -li 24 -l "Setup Connections" -la "center" -mh 4 -bs "etchedIn" jsfWinSetupFrame;
			formLayout -nd 100 jsfWinSetupForm;
				//current control stuff
				$txt1 = `text -l "  Current Control:"`;
				textField -tx "create or specify a control to begin..." jsfWinCurCtlField;
				button -l "  <<<  " -bgc ($btnCol.x) ($btnCol.y) ($btnCol.z) -c "jsUpdate" -ann "Set's the selected control as the current control" jsfWinCurCtlBtn;
				
				//blend shape list stuff
				optionMenu -acc -cc "jsfWinBSOptionMenuChange" jsfWinBSOptionMenu;
					menuItem -l "                                             ";
					menuItem -l "hello";
				button -l "Refresh" -c "jsUpdateBlendsList" jsfWinBSOptionMenuRefresh;
				
				$sep1 = `separator -h 1 -st "in"`;
				
				textScrollList -sc "jsSelectBlend" -ams 1 jsfWinBSTextList;
				button -l "Add" -bgc ($btnCol.x) ($btnCol.y) ($btnCol.z) -c "jsAddBlend" jsfWinBSListAdd;
				button -l "Remove" -bgc ($btnCol.x) ($btnCol.y) ($btnCol.z) -c "jsRemoveSelectedBlend" jsfWinBSListRemove;
				button -l "Clear" -bgc ($btnCol.x) ($btnCol.y) ($btnCol.z) -c "textScrollList -e -ra jsfWinBSTextList" jsfWinBSListClear;
				
				frameLayout -w 84 -h 96 -l "connect to..." -li 4 -bv 0 jsfWinConnectFrame;
					formLayout -nd 100 jsfWinConnectForm;
						$txt2 = `text -en 0 -l "O"`;
						button -c "jsConnectControlCorners topLeft" -vis 0 -w 20 -h 20 -l "" -bgc ($btnCol.x) ($btnCol.y) ($btnCol.z) jsfWinConnectBtn1;
						button -c "jsConnectControlVertical top" -vis 0 -w 20 -h 20 -l "+y" -bgc ($btnCol.x) ($btnCol.y) ($btnCol.z) jsfWinConnectBtn2;
						button -c "jsConnectControlCorners topRight" -vis 0 -w 20 -h 20 -l "" -bgc ($btnCol.x) ($btnCol.y) ($btnCol.z) jsfWinConnectBtn3;
						button -c "jsConnectControlHorizontal left" -vis 0 -w 20 -h 20 -l "-x" -bgc ($btnCol.x) ($btnCol.y) ($btnCol.z) jsfWinConnectBtn4;
						button -c "jsConnectControlHorizontal right" -vis 0 -w 20 -h 20 -l "+x" -bgc ($btnCol.x) ($btnCol.y) ($btnCol.z) jsfWinConnectBtn5;
						button -c "jsConnectControlCorners bottomLeft" -vis 0 -w 20 -h 20 -l "" -bgc ($btnCol.x) ($btnCol.y) ($btnCol.z) jsfWinConnectBtn6;
						button -c "jsConnectControlVertical bottom" -vis 0 -w 20 -h 20 -l "-y" -bgc ($btnCol.x) ($btnCol.y) ($btnCol.z) jsfWinConnectBtn7;
						button -c "jsConnectControlCorners bottomRight" -vis 0 -w 20 -h 20 -l "" -bgc ($btnCol.x) ($btnCol.y) ($btnCol.z) jsfWinConnectBtn8;
					formLayout -e
						-ap $txt2 "top" -6 50 -ap $txt2 "left" -3 50
						-ap jsfWinConnectBtn1 "top" 2 0 -ap jsfWinConnectBtn1 "left" 2 0
						-ap jsfWinConnectBtn2 "top" 2 0 -ap jsfWinConnectBtn2 "left" 2 35
						-ap jsfWinConnectBtn3 "top" 2 0 -ap jsfWinConnectBtn3 "right" 2 100
						-ap jsfWinConnectBtn4 "top" 2 35 -ap jsfWinConnectBtn4 "left" 2 0
						-ap jsfWinConnectBtn5 "top" 2 35 -ap jsfWinConnectBtn5 "right" 2 100
						-ap jsfWinConnectBtn6 "bottom" 2 100 -ap jsfWinConnectBtn6 "left" 2 0
						-ap jsfWinConnectBtn7 "bottom" 2 100 -ap jsfWinConnectBtn7 "left" 2 35
						-ap jsfWinConnectBtn8 "bottom" 2 100 -ap jsfWinConnectBtn8 "right" 2 100
						jsfWinConnectForm;
						
				
				
			
			formLayout -e
				//current control positioning
				-ap $txt1 "left" 2 0 -ap $txt1 "top" 2 0
				-ac jsfWinCurCtlField "left" 2 $txt1 -ac jsfWinCurCtlField "right" 2 jsfWinCurCtlBtn
				-ap jsfWinCurCtlBtn "right" 2 100
				
				-ac $sep1 "top" 9 $txt1
				-ap $sep1 "left" 8 0
				-ap $sep1 "right" 8 100
				
				//blend shape list positioning
				-ac jsfWinBSOptionMenu "top" 16 $txt1
				-ap jsfWinBSOptionMenu "left" 2 0
				
				-ac jsfWinBSOptionMenuRefresh "top" 16 $txt1
				-ac jsfWinBSOptionMenuRefresh "left" 4 jsfWinBSOptionMenu
				
				-ac jsfWinBSTextList "top" 4 jsfWinBSOptionMenu
				-ap jsfWinBSTextList "left" 2 0
				-ap jsfWinBSTextList "right" 90 100
				-ac jsfWinBSTextList "bottom" 2 jsfWinBSListAdd
				
				-ap jsfWinBSListAdd "left" 2 0
				-ap jsfWinBSListAdd "bottom" 2 100
				-ap jsfWinBSListAdd "right" 2 20
				
				-ap jsfWinBSListRemove "left" 2 20
				-ap jsfWinBSListRemove "bottom" 2 100
				-ap jsfWinBSListRemove "right" 2 40
				
				-ap jsfWinBSListClear "left" 2 40
				-ap jsfWinBSListClear "bottom" 2 100
				-ap jsfWinBSListClear "right" 90 100
				
				//connection form positioning
				-ap jsfWinConnectFrame "top" 0 45
				-ap jsfWinConnectFrame "bottom" -96 45
				-ap jsfWinConnectFrame "right" 3 100
				-ap jsfWinConnectFrame "left" -86 100
				
				jsfWinSetupForm;
	
	formLayout -e
		-ap jsfWinBtnGridFrame "left" 2 0
		-ap jsfWinBtnGridFrame "top" 2 0
		-ap jsfWinBtnGridFrame "right" 2 100
		
		-ap jsfWinSetupFrame "left" 2 0
		-ac jsfWinSetupFrame "top" 10 jsfWinBtnGridFrame
		-ap jsfWinSetupFrame "right" 2 100
		-ap jsfWinSetupFrame "bottom" 2 100
		
		jsfWinMainForm;
		
	
	window -e -w 364 -h 690 $win;
	showWindow $win;
	
	//populate the blends list
	jsUpdateBlendsList();
};



//====================================================================================================
global proc jsUpdateBlendsList() {
//populates the small blends list with all of the blendshapes in the scene

	//get all blends in the scene
	string $blends[] = `ls -typ blendShape`;
	
	//clear the list
	string $curList[] = `optionMenu -q -ill jsfWinBSOptionMenu`;
	for ($item in $curList) {
		deleteUI -mi $item;
	}
	
	setParent -m jsfWinBSOptionMenu;
	//buffer item
	for ($blend in $blends) {
		menuItem -l $blend;
	}
	
	//add the attributes if theres only one blendshape
	if(size($blends)==1) {
		select $blends[0];
		textScrollList -e -ra jsfWinBSTextList;
		jsAddBlend();
	}
}
global proc jsSelectBlend() {
//selects the blend target highlighted in the main text scroll list (if it exists)

	//get the name of the selected item
	string $selectedName[] = `textScrollList -q -si jsfWinBSTextList`;
	//buffer for tokenize
	string $buffer[];
	int $i;
	//loop through all selected item
	for ($i = 0; $i < size($selectedName); $i++)
	{
		//if it's the first item selected
		if ($i == 0)
		{
			//tokenize the name
			tokenize $selectedName[$i] "." $buffer;
			//if the blend exists clear selection and select it
			if (`objExists $buffer[1]`)
				select -r $buffer[1];
			
		}
		//if it's not the first object
		else if ($i >= 1)
		{
			//tokenize the name
			tokenize $selectedName[$i] "." $buffer;
			//if the object exists add it to the selection
			if (`objExists $buffer[1]`)
				select -add $buffer[1];
		}
	}
	
}
	

global proc jsRemoveSelectedBlend() {
//removes the selected name in the textScrollList

	//get the name of the selected item
	string $selectedName[] = `textScrollList -q -si jsfWinBSTextList`;
	string $selName;
	
	for ($selName in $selectedName)
	{
	
		//remove the selected item
		textScrollList -e -ri $selName jsfWinBSTextList;
	
		//print that it was succesful
		print ($selName+" removed from list\n");
	
	}
	
}
global proc jsAddBlend(){
//add all the attribute of the selected object to the textScrollList

	string $selected[] = `ls -sl`;
	
	//clear the list
	if (!size($selected))
		return;
	
	//variable for loop
	string $sel;
	
	//loop through all selected object
	for ($sel in $selected)
	{
		//list atributes of selected objects
		//-multi -scalar -read -connectable -keyable -visible
		string $blendAttrs[]=`listAttr -m -s -r -c -k -v $sel`;
		string $attr;
		
		//loop through all attributes and add them to the textScrollList
		for ($attr in $blendAttrs) {
			//check if the object is already on the list
			string $attrList[] = `textScrollList -q -ai jsfWinBSTextList`;
			int $dup = 0;
			
			for ($attrExist in $attrList) {
				if (($sel+"."+$attr) == $attrExist) $dup = 1;
			}
			
			//if dup was not set to true, then the object is not already on the list
			if ($dup == 0) {
				string $match = `match "envelope" $attr`;
				if ($match != "envelope")
				textScrollList -e -a ($sel+"."+$attr) jsfWinBSTextList;
			}
		}
	}
}
global proc jsfWinBSOptionMenuChange() {
//loads the attributes of the blendshape that is selected from the option menu
//this is the changeCommand on the optionMenu

	string $selList[] = `ls -r 1 -sl`;
	string $selItem = `optionMenu -q -v jsfWinBSOptionMenu`;
	
	select -r $selItem;
	textScrollList -e -ra jsfWinBSTextList;
	jsAddBlend;
	
	select $selList;
}



//====================================================================================================
global proc jsCreateControl(string $createProc) {
	global string $jsfWinLastCtlName;
	
	string $name;
	string $result = `promptDialog
			-title "Create New Control..."
			-text $jsfWinLastCtlName
			-message "Enter Name:"
			-button "OK" -button "Cancel"
			-defaultButton "OK" -cancelButton "Cancel"
			-dismissString "Cancel"`;
	
	if ($result == "OK") {
		$name = `promptDialog -query -text`;
	} else {
		return;
	}
	
	if (!isValidObjectName($name)) {
		error ("Sorry, "+$name+" is not a valid object name");
	}
	
	$jsfWinLastCtlName = $name;
	eval($createProc+" "+$name);
}



global proc jsCreateTypeAControl(string $name) {
	global int $jsTypeFActive;
	//check operating system
	string $os = `about -os`;
	
	//check if object by that name already exists
	if (!`objExists ($name+"Grp")`)
	{
		//check if it is a type F or A
		int $typef = $jsTypeFActive;
		
		//create empty group node
		group -em -n ($name+"Grp");
		//add type attribute
		addAttr -ln "type" -dt "string" ($name+"Grp");
		
		//check if object is an F type
		//if it is create control for f
		if ($typef)
		{
			setAttr -type "string" ($name+"Grp.type") "Fa"; 
			nurbsSquare -c 0 0 0 -nr 0 0 1 -sl1 1.05 -sl2 .3  -sps 1 -d 3 -ch 0 -n ($name+"InnerSquare") ;
			nurbsSquare -c 0 0 0 -nr 0 0 1 -sl1 1.1 -sl2 .4  -sps 1 -d 3 -ch 0 -n ($name+"OuterSquare");
			
			circle -c 0 0 0 -nr 0 0 1 -sw 360 -r .15 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n ($name+"CircleCtrl");
			scale 1 .25 1 ($name+"CircleCtrl");
			
		}
			
		//if it isn't an F type create control for A
		else if (!$typef)
		{
			
			setAttr -type "string" ($name+"Grp.type") "A"; 
			nurbsSquare -c 0 0 0 -nr 0 0 1 -sl1 2 -sl2 .3  -sps 1 -d 3 -ch 0 -n ($name+"InnerSquare") ;
			nurbsSquare -c 0 0 0 -nr 0 0 1 -sl1 2.1 -sl2 .4  -sps 1 -d 3 -ch 0 -n ($name+"OuterSquare");
			
			circle -c 0 0 0 -nr 0 0 1 -sw 360 -r .15 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n ($name+"CircleCtrl");
			scale 1 .5 1 ($name+"CircleCtrl");
			
		}
		
		
		//now always create text...
		if (1)
		{
			//create text for linux
			if ($os == "linux")
				textCurves -n ($name+"Text") -ch 0 -f "Courier" -t ($name);
			//create text for NT
			else if ($os == "nt" || $os == "win64")
			{
				//textCurves -n ($name+"Text")-ch 0 -f "Times New Roman-Regular" -t "Maya";

				textCurves -n ($name+"Text") -ch 0 -f "Arial|h-4|w400|c0" -t ($name);
				//textCurves -n ($name+"Text") -ch 0 -f "Times New Roman-Regular" -t ($name);
				string $relatives[] = `listRelatives`;
				string $con;
				string $connections[] = `listConnections $relatives[0]`;
				for ($con in $connections)
				{
					string $match = `match "^makeText" $con`;
					if ($match == "makeText")
						delete $con;
				}
				
			}
	
			xform -cp ($name+"TextShape");
			pointConstraint -n ($name+"TempConst") ($name+"Grp") ($name+"TextShape");
			delete ($name+"TempConst");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($name+"TextShape");
			scale .4 .4 .4 ($name+"TextShape");
			move 0 1.3 0 ($name+"TextShape"); 
			setAttr ($name+"TextShape.template") 1;
			parent ($name+"TextShape") ($name+"Grp");
			connectAttr -f ($name+"CircleCtrl.v") ($name+"TextShape.v");
		}
		
		//set the squares to be templated
		setAttr ($name+"InnerSquare.template") 1;
		setAttr ($name+"OuterSquare.template") 1;
		
		
		
		
		//set the limits on the circle control
		transformLimits -tz  0 0 -etz 1 1 ($name+"CircleCtrl");
		transformLimits -tx  0 0 -etx 1 1 ($name+"CircleCtrl");
		transformLimits -ty -1 1 -ety 1 1 ($name+"CircleCtrl");
		
		//add message name attribute
		addAttr -ln "name" -dt "string" ($name+"CircleCtrl");
		setAttr -type "string" ($name+"CircleCtrl.name") $name; 
		
		//parent everything under the main group node
		parent ($name+"CircleCtrl") ($name+"InnerSquare") ($name+"OuterSquare") ($name+"Grp");
		
		//if control type is F make certain changes to control
		if ($typef)
		{
			scale 1 2 1 ($name+"Grp");
			
			move 0 1 0 ($name+"InnerSquare");
			move 0 1 0 ($name+"OuterSquare");
			
			if (1)
			{
				scale .4 .2 .4 ($name+"TextShape");
				xform -ws -t 0 2.35 0 ($name+"TextShape");
			}
			
			transformLimits -ty 0 1 -ety 1 1 ($name+"CircleCtrl");
			
		}
		
		//lock attributes on control that are not needed
		jsLockHideAttr ($name+"CircleCtrl");
		
		//connect visibility of circle control to range controls
		connectAttr -f ($name+"CircleCtrl.v") ($name+"InnerSquare.v");
		connectAttr -f ($name+"CircleCtrl.v") ($name+"OuterSquare.v");
		
		//change active text field to the control that was just created's name 
		textField -e -tx ($name) jsfWinCurCtlField;
		
		//set default manipulator tool
		select -r ($name+"CircleCtrl");
		setDefaultManip 1;
		
		//select the group for translation
		select -r ($name+"Grp");
		
		//check the control type and disable buttons that are not active
		jsCheckControlType;
	
	}
	//if the object already exists print the error
	else if (`objExists ($name+"Grp")`)
	{
		warning "Control already exists. Please change control name!\n";
		return;
	}
	
}

//------------------------------------------------------------------------------------------------------------//
//	PROC:	jsCreateTypeBControl
//	
//		This procedure will create the control typeB 
//------------------------------------------------------------------------------------------------------------//

global proc jsCreateTypeBControl(string $name) {
	global int $jsTypeFActive;
	
	//check operating system
	string $os = `about -os`;
	
	//check if object by that name already exists
	if (!`objExists ($name+"Grp")`)
	{
		
		//check if it is a type F or A
		int $typef = $jsTypeFActive;
		//create empty group node
		group -em -n ($name+"Grp");
		//add type attribute
		addAttr -ln "type" -dt "string" ($name+"Grp");
		
		//check if object is an F type
		//if it is create control for f
		if ($typef)
		{
			setAttr -type "string" ($name+"Grp.type") "Fb"; 
			nurbsSquare -c 0 0 0 -nr 0 0 1 -sl1 .3 -sl2 1.05  -sps 1 -d 3 -ch 0 -n ($name+"InnerSquare") ;
			nurbsSquare -c 0 0 0 -nr 0 0 1 -sl1 .4 -sl2 1.1  -sps 1 -d 3 -ch 0 -n ($name+"OuterSquare");
			
			circle -c 0 0 0 -nr 0 0 1 -sw 360 -r .15 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n ($name+"CircleCtrl");
			scale .25 1 1 ($name+"CircleCtrl");
			
		}
			
		//if it isn't an F type create control for A
		else if (!$typef)
		{
			
			setAttr -type "string" ($name+"Grp.type") "B"; 
			nurbsSquare -c 0 0 0 -nr 0 0 1 -sl1 .3 -sl2 2  -sps 1 -d 3 -ch 0 -n ($name+"InnerSquare") ;
			nurbsSquare -c 0 0 0 -nr 0 0 1 -sl1 .4 -sl2 2.1  -sps 1 -d 3 -ch 0 -n ($name+"OuterSquare");
			circle -c 0 0 0 -nr 0 0 1 -sw 360 -r .15 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n ($name+"CircleCtrl");
			scale .5 1 1 ($name+"CircleCtrl");
			
		
		}
		
		//check if text should be created
		if (1)
		{
			//create text for linux
			if ($os == "linux")
				textCurves -n ($name+"Text") -ch 0 -f "Courier" -t ($name);
			//create text for NT
			else if ($os == "nt" || $os == "win64")
			{
				textCurves -n ($name+"Text") -ch 0 -f "Arial|h-4|w400|c0" -t ($name);
				string $relatives[] = `listRelatives`;
				string $con;
				string $connections[] = `listConnections $relatives[0]`;
				for ($con in $connections)
				{
					string $match = `match "^makeText" $con`;
					if ($match == "makeText")
						delete $con;
				}
				
			}
			xform -cp ($name+"TextShape");
			pointConstraint -n ($name+"TempConst") ($name+"Grp") ($name+"TextShape");
			delete ($name+"TempConst");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($name+"TextShape");
			scale .4 .4 .4 ($name+"TextShape");
			move 0 .45 0 ($name+"TextShape"); 
			setAttr ($name+"TextShape.template") 1;
			parent ($name+"TextShape") ($name+"Grp");
			connectAttr -f ($name+"CircleCtrl.v") ($name+"TextShape.v");
		}
		
		//set the squares to be templated
		setAttr ($name+"InnerSquare.template") 1;
		setAttr ($name+"OuterSquare.template") 1;
		
		
		
		
		//set the limits on the circle control
		transformLimits -tz  0 0 -etz 1 1 ($name+"CircleCtrl");
		transformLimits -tx -1 1 -etx 1 1 ($name+"CircleCtrl");
		transformLimits -ty  0 0 -ety 1 1 ($name+"CircleCtrl");
		
		
		//add message name attribute
		addAttr -ln "name" -dt "string" ($name+"CircleCtrl");
		setAttr -type "string" ($name+"CircleCtrl.name") $name; 
		
		//parent everything under the main group node
		parent ($name+"CircleCtrl") ($name+"InnerSquare") ($name+"OuterSquare") ($name+"Grp");
		
		//if control type is F make certain changes to control
		if ($typef)
		{
			scale 2 1 1 ($name+"Grp");
			
			move 1 0 0 ($name+"InnerSquare");
			move 1 0 0 ($name+"OuterSquare");
			
			if (1)
			{
				scale .2 .4 .4 ($name+"TextShape");
				
				move -r 1 0 0 ($name+"TextShape");
			}
				
			transformLimits -tx 0 1 -etx 1 1 ($name+"CircleCtrl");
			
		}
		
		//lock attributes on control that are not needed
		jsLockHideAttr ($name+"CircleCtrl");
		
		//connect visibility of circle control to range controls
		connectAttr -f ($name+"CircleCtrl.v") ($name+"InnerSquare.v");
		connectAttr -f ($name+"CircleCtrl.v") ($name+"OuterSquare.v");
		
		//change active text field to the control that was just created's name 
		textField -e -tx ($name) jsfWinCurCtlField;
		
		//set default manipulator tool
		select -r ($name+"CircleCtrl");
		setDefaultManip 1;
		
		//select the group for translation
		select -r ($name+"Grp");
		
		//check the control type and disable buttons that are not active
		jsCheckControlType;
	}
	
	//if the object already exists print the error
	else if (`objExists ($name+"Grp")`)
	{
		warning "Control already exists. Please change control name!\n";
		return;
	}
	
}

//------------------------------------------------------------------------------------------------------------//
//	PROC:	jsCreateTypeCControl
//	
//		This procedure will create the control typeC
//------------------------------------------------------------------------------------------------------------//

global proc jsCreateTypeCControl(string $name)
{
	//check operating system
	string $os = `about -os`;
	
	//check if object by that name already exists
	if (!`objExists ($name+"Grp")`)
	{
		
		//create empty group node
		group -em -n ($name+"Grp");
		
		//add type attribute
		addAttr -ln "type" -dt "string" ($name+"Grp");
		
		//create control
		setAttr -type "string" ($name+"Grp.type") "C"; 
		nurbsSquare -c 0 0 0 -nr 0 0 1 -sl1 2 -sl2 2 -sps 1 -d 3 -ch 0 -n ($name+"InnerSquare") ;
		nurbsSquare -c 0 0 0 -nr 0 0 1 -sl1 2.1 -sl2 2.1 -sps 1 -d 3 -ch 0 -n ($name+"OuterSquare");
		
		circle -c 0 0 0 -nr 0 0 1 -sw 360 -r .15 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n ($name+"CircleCtrl");
		scale 1 1 1 ($name+"CircleCtrl");
		
		
		//check if text should be created
		if (1)
		{
			//create text for linux
			if ($os == "linux")
				textCurves -n ($name+"Text") -ch 0 -f "Courier" -t ($name);
			//create text for NT
			else if ($os == "nt" || $os == "win64")
			{
				textCurves -n ($name+"Text") -ch 0 -f "Arial|h-4|w400|c0" -t ($name);
				string $relatives[] = `listRelatives`;
				string $con;
				string $connections[] = `listConnections $relatives[0]`;
				for ($con in $connections)
				{
					string $match = `match "^makeText" $con`;
					if ($match == "makeText")
						delete $con;
				}
				
			}
			xform -cp ($name+"TextShape");
			pointConstraint -n ($name+"TempConst") ($name+"Grp") ($name+"TextShape");
			delete ($name+"TempConst");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($name+"TextShape");
			scale .4 .4 .4 ($name+"TextShape");
			move 0 1.3 0 ($name+"TextShape"); 
			setAttr ($name+"TextShape.template") 1;
			parent ($name+"TextShape") ($name+"Grp");
			connectAttr -f ($name+"CircleCtrl.v") ($name+"TextShape.v");
		}
		//set the squares to be templated
		setAttr ($name+"InnerSquare.template") 1;
		setAttr ($name+"OuterSquare.template") 1;
		
		
		
		
		//set the limits on the circle control
		transformLimits -tz -0 0 -etz 1 1 ($name+"CircleCtrl");
		transformLimits -tx -1 1 -etx 1 1 ($name+"CircleCtrl");
		transformLimits -ty -1 1 -ety 1 1 ($name+"CircleCtrl");
		
		//add message name attribute
		addAttr -ln "name" -dt "string" ($name+"CircleCtrl");
		setAttr -type "string" ($name+"CircleCtrl.name") $name; 
		
		//parent everything under the main group node
		parent ($name+"CircleCtrl") ($name+"InnerSquare") ($name+"OuterSquare") ($name+"Grp");
		
		//lock attributes on control that are not needed
		jsLockHideAttr ($name+"CircleCtrl");
		
		//connect visibility of circle control to range controls
		connectAttr -f ($name+"CircleCtrl.v") ($name+"InnerSquare.v");
		connectAttr -f ($name+"CircleCtrl.v") ($name+"OuterSquare.v");
		
		//change active text field to the control that was just created's name 
		textField -e -tx ($name) jsfWinCurCtlField;
		
		//set default manipulator tool
		select -r ($name+"CircleCtrl");
		setDefaultManip 1;
		
		//select the group for translation
		select -r ($name+"Grp");
		
		//check the control type and disable buttons that are not active
		jsCheckControlType;
	}
	//if the object already exists print the error
	else if (`objExists ($name+"Grp")`)
	{
		warning "Control already exists. Please change control name!\n";
		return;
	}
}

//------------------------------------------------------------------------------------------------------------//
//	PROC:	jsCreateTypeDControl
//	
//		This procedure will create the control typeD 
//------------------------------------------------------------------------------------------------------------//

global proc jsCreateTypeDControl(string $name)
{
	//check operating system
	string $os = `about -os`;
	
	global int $jsTypeD50Active;
	
	//check if object by that name already exists
	if (!`objExists ($name+"Grp")`)
	{
		
		//check if it is a type fifty or not
		int $fifty = $jsTypeD50Active;
		
		//create empty group node
		group -em -n ($name+"Grp");
		
		//add type attribute
		addAttr -ln "type" -dt "string" ($name+"Grp");
		
		//check if object is a fifty type
		//if it is create control for fifty
		if ($fifty)
		{
			setAttr -type "string" ($name+"Grp.type") "50"; 
		}
		
		//if it isn't a fifty type create control for D
		else if (!$fifty)
		{
			setAttr -type "string" ($name+"Grp.type") "D"; 
		}
		
		nurbsSquare -c 0 .5 0 -nr 0 0 1 -sl1 1 -sl2 2 -sps 1 -d 3 -ch 0 -n ($name+"InnerSquare") ;
		nurbsSquare -c 0 .5 0 -nr 0 0 1 -sl1 1.1 -sl2 2.1 -sps 1 -d 3 -ch 0 -n ($name+"OuterSquare");
			
		circle -c 0 0 0 -nr 0 0 1 -sw 360 -r .15 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n ($name+"CircleCtrl");
		scale 1 1 1 ($name+"CircleCtrl");
		
		
		//check if text should be created
		if (1)
		{
			//create text for linux
			if ($os == "linux")
				textCurves -n ($name+"Text") -ch 0 -f "Courier" -t ($name);
			//create text for NT
			else if ($os == "nt" || $os == "win64")
			{
				textCurves -n ($name+"Text") -ch 0 -f "Arial|h-4|w400|c0" -t ($name);
				string $relatives[] = `listRelatives`;
				string $con;
				string $connections[] = `listConnections $relatives[0]`;
				for ($con in $connections)
				{
					string $match = `match "^makeText" $con`;
					if ($match == "makeText")
						delete $con;
				}
				
			}
			xform -cp ($name+"TextShape");
			pointConstraint -n ($name+"TempConst") ($name+"Grp") ($name+"TextShape");
			delete ($name+"TempConst");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($name+"TextShape");
			scale .4 .4 .4 ($name+"TextShape");
			move 0 1.3 0 ($name+"TextShape"); 
			setAttr ($name+"TextShape.template") 1;
			parent ($name+"TextShape") ($name+"Grp");
			connectAttr -f ($name+"CircleCtrl.v") ($name+"TextShape.v");
		}
		
		//set the squares to be templated
		setAttr ($name+"InnerSquare.template") 1;
		setAttr ($name+"OuterSquare.template") 1;
		
		
		
		
		//set the limits on the circle control
		transformLimits -tz -0 0 -etz 1 1 ($name+"CircleCtrl");
		transformLimits -tx -1 1 -etx 1 1 ($name+"CircleCtrl");
		transformLimits -ty  0 1 -ety 1 1 ($name+"CircleCtrl");
		
		//add message name attribute
		addAttr -ln "name" -dt "string" ($name+"CircleCtrl");
		setAttr -type "string" ($name+"CircleCtrl.name") $name; 
		
		//parent everything under the main group node
		parent ($name+"CircleCtrl") ($name+"InnerSquare") ($name+"OuterSquare") ($name+"Grp");
		
		
		//lock attributes on control that are not needed
		jsLockHideAttr ($name+"CircleCtrl");
		
		//connect visibility of circle control to range controls
		connectAttr -f ($name+"CircleCtrl.v") ($name+"InnerSquare.v");
		connectAttr -f ($name+"CircleCtrl.v") ($name+"OuterSquare.v");
		
		//change active text field to the control that was just created's name 
		textField -e -tx ($name) jsfWinCurCtlField;
		
		//set default manipulator tool
		select -r ($name+"CircleCtrl");
		setDefaultManip 1;
		
		//select the group for translation
		select -r ($name+"Grp");
		
		//check the control type and disable buttons that are not active
		jsCheckControlType;
	}
	
	//if the object already exists print the error
	else if (`objExists ($name+"Grp")`)
	{
		warning "Control already exists. Please change control name!\n";
		return;
	}
}

//------------------------------------------------------------------------------------------------------------//
//	PROC:	jsCreateTypeEControl
//	
//		This procedure will create the control typeE 
//------------------------------------------------------------------------------------------------------------//

global proc jsCreateTypeEControl(string $name)
{
	
	//check operating system
	string $os = `about -os`;
	
	//check if object by that name already exists
	if (!`objExists ($name+"Grp")`)
	{
		//create empty group node
		group -em -n ($name+"Grp");
		//add type attribute
		addAttr -ln "type" -dt "string" ($name+"Grp");
		//set attribute type to E
		setAttr -type "string" ($name+"Grp.type") "E"; 
		nurbsSquare -c .5 .5 0 -nr 0 0 1 -sl1 1 -sl2 1 -sps 1 -d 3 -ch 0 -n ($name+"InnerSquare") ;
		nurbsSquare -c .5 .5 0 -nr 0 0 1 -sl1 1.1 -sl2 1.1 -sps 1 -d 3 -ch 0 -n ($name+"OuterSquare");
		
		circle -c 0 0 0 -nr 0 0 1 -sw 360 -r .15 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n ($name+"CircleCtrl");
		scale 1 1 1 ($name+"CircleCtrl");
		
		
		//check if text should be created
		if (1)
		{
			//create text for linux
			if ($os == "linux")
				textCurves -n ($name+"Text") -ch 0 -f "Courier" -t ($name);
			//create text for NT
			else if ($os == "nt" || $os == "win64")
			{
				textCurves -n ($name+"Text") -ch 0 -f "Arial|h-4|w400|c0" -t ($name);
				string $relatives[] = `listRelatives`;
				string $con;
				string $connections[] = `listConnections $relatives[0]`;
				for ($con in $connections)
				{
					string $match = `match "^makeText" $con`;
					if ($match == "makeText")
						delete $con;
				}
				
			}
			xform -cp ($name+"TextShape");
			pointConstraint -n ($name+"TempConst") ($name+"Grp") ($name+"TextShape");
			delete ($name+"TempConst");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($name+"TextShape");
			scale .4 .4 .4 ($name+"TextShape");
			move .5 1.3 0 ($name+"TextShape"); 
			setAttr ($name+"TextShape.template") 1;
			parent ($name+"TextShape") ($name+"Grp");
			connectAttr -f ($name+"CircleCtrl.v") ($name+"TextShape.v");
		}
		
		//set the squares to be templated
		setAttr ($name+"InnerSquare.template") 1;
		setAttr ($name+"OuterSquare.template") 1;
		
		
		
		//set the limits on the circle control
		transformLimits -tz -0 0 -etz 1 1 ($name+"CircleCtrl");
		transformLimits -tx  0 1 -etx 1 1 ($name+"CircleCtrl");
		transformLimits -ty  0 1 -ety 1 1 ($name+"CircleCtrl");
		
		//add message name attribute
		addAttr -ln "name" -dt "string" ($name+"CircleCtrl");
		setAttr -type "string" ($name+"CircleCtrl.name") $name; 
		
		//parent everything under the main group node
		parent ($name+"CircleCtrl") ($name+"InnerSquare") ($name+"OuterSquare") ($name+"Grp");
		
		//lock attributes on control that are not needed
		jsLockHideAttr ($name+"CircleCtrl");
		
		//connect visibility of circle control to range controls
		connectAttr -f ($name+"CircleCtrl.v") ($name+"InnerSquare.v");
		connectAttr -f ($name+"CircleCtrl.v") ($name+"OuterSquare.v");
		
		//change active text field to the control that was just created's name 
		textField -e -tx ($name) jsfWinCurCtlField;
		
		//set default manipulator tool
		select -r ($name+"CircleCtrl");
		setDefaultManip 1;
		
		//select the group for translation
		select -r ($name+"Grp");
		
		//check the control type and disable buttons that are not active
		jsCheckControlType;
	}
	
	//if the object already exists print the error
	else if (`objExists ($name+"Grp")`)
	{
		warning "Control already exists. Please change control name!\n";
		return;
	}
}

//------------------------------------------------------------------------------------------------------------//
//	PROC:	jsLockHideAttr
//	
//		This procedure will hide and lock attributes that are not needed 
//------------------------------------------------------------------------------------------------------------//

global proc jsLockHideAttr(string $name)
{
	
		
	//lock translate Z
	setAttr -lock true ($name+".tz");
	setAttr -keyable false ($name+".tz");
	
	//lock rotate X
	setAttr -lock true ($name+".rx");
	setAttr -keyable false ($name+".rx");
	
	//lock rotate Y
	setAttr -lock true ($name+".ry");
	setAttr -keyable false ($name+".ry");
	
	//lock rotate Z
	setAttr -lock true ($name+".rz");
	setAttr -keyable false ($name+".rz");
	
	//lock scale X
	setAttr -lock true ($name+".sx");
	setAttr -keyable false ($name+".sx");
	
	//lock scale Y
	setAttr -lock true ($name+".sy");
	setAttr -keyable false ($name+".sy");
	
	//lock scale Z
	setAttr -lock true ($name+".sz");
	setAttr -keyable false ($name+".sz");
	
	
	//remove the comment lines if you want to also lock visibility
	//setAttr -lock true ($name+".visibility");
	//setAttr -keyable false ($name+".visibility");
	
}

//------------------------------------------------------------------------------------------------------------//
//	PROC:	jsConnectControlVertical
//	
//		This procedure will make a vertical connection between the control 
//		and the selected item. 
//------------------------------------------------------------------------------------------------------------//

global proc jsConnectControlVertical(string $position)
{
	//get the name of the control
	string $name =`textField -q -tx jsfWinCurCtlField`; 
	
	if (`objExists ($name+"Grp")`)
	{
	
		//get the name of the selected item
		string $selectedName[] = `textScrollList -q -si jsfWinBSTextList`;
		string $selName;
		//loop through all the selected items
		for ($selName in $selectedName)
		{
			
			
			//check position
			if ($position == "top")
			{
				//create clamp node
				string $topClampName = `shadingNode -n ($name+"TopClamp") -asUtility clamp`;
				//set clamp max and min
				setAttr ($topClampName+".maxR") 1;
				setAttr ($topClampName+".minR") 0;
				//connect control to clamp and clamp to blend
				connectAttr -f ($name+"CircleCtrl.ty") ($topClampName+".inputR");
				connectAttr -f ($topClampName+".outputR") $selName;
				
			}
			//check position
			else if ($position == "bottom")
			{
				//create clamp node
				string $bottomClampName = `shadingNode -n ($name+"BottomClamp") -asUtility clamp`;
				//create multiply divide node
				string $bottomMultName = `shadingNode -n ($name+"BottomMultDivide") -asUtility multiplyDivide`;
				//set operation to multiply and input 2 to -1
				setAttr ($bottomMultName+".operation") 1;
				setAttr ($bottomMultName+".input2X") -1;
				
				//set clamp max and min
				setAttr ($bottomClampName+".maxR") 1;
				setAttr ($bottomClampName+".minR") 0;
			
				//connect the control to the input of the multDivide node
				connectAttr -f ($name+"CircleCtrl.ty") ($bottomMultName+".input1X");
				//connect the multDivide node into the input R of the clamp node
				connectAttr -f ($bottomMultName+".outputX") ($bottomClampName+".inputR");
				//connect the output of the clamp node into the selected attribute
				connectAttr -f ($bottomClampName+".outputR") $selName;
			}
		
		
			//print that it was succesful
			print ("connection succesfully made!\n");
		
		}
	}

	
	
	else if (!`objExists ($name+"Grp")`) {
		warning ("No control named "+$name+" exists. Please update the active control!\n");
		jsClearActiveCtl;
		return;
	}
}

//------------------------------------------------------------------------------------------------------------//
//	PROC:	jsConnectControlHorizontal
//	
//		This procedure will make a horizontal connection between the control 
//		and the selected item. 
//------------------------------------------------------------------------------------------------------------//

global proc jsConnectControlHorizontal(string $position)
{
	//get the name of the control
	string $name =`textField -q -tx jsfWinCurCtlField`; 
	
	if (`objExists ($name+"Grp")`)
	{
		//get the name of the selected item
		string $selectedName[] = `textScrollList -q -si jsfWinBSTextList`;
		string $selName;
		
		//loop through all the selected names
		for ($selName in $selectedName)
		{
			
			
			//check position
			if ($position == "right")
			{
				//create clamp node
				string $rightClampName = `shadingNode -n ($name+"RightClamp") -asUtility clamp`;
				
				//set clamp max and min
				setAttr ($rightClampName+".maxR") 1;
				setAttr ($rightClampName+".minR") 0;
				//connect control to clamp and clamp to blend
				connectAttr -f ($name+"CircleCtrl.tx") ($rightClampName+".inputR");
				connectAttr -f ($rightClampName+".outputR") $selName;
				
				
			}
			//check position
			else if ($position == "left")
			{
				string $leftClampName = `shadingNode -n ($name+"LeftClamp") -asUtility clamp`;
				string $leftMultName = `shadingNode -n ($name+"LeftMultDivide") -asUtility multiplyDivide`;
				setAttr ($leftMultName+".operation") 1;
				setAttr ($leftMultName+".input2X") -1;
				
				//set clamp max and min
				setAttr ($leftClampName+".maxR") 1;
				setAttr ($leftClampName+".minR") 0;
			
				connectAttr -f ($name+"CircleCtrl.tx") ($leftMultName+".input1X");
				connectAttr -f ($leftMultName+".outputX") ($leftClampName+".inputR");
				connectAttr -f ($leftClampName+".outputR") $selName;
				
			}
		
		
			//print that it was succesful
			print ("connection succesfully made!\n");
		
		}
	}
	
	else if (!`objExists ($name+"Grp")`) {
		warning ("No control named "+$name+" exists. Please update the active control!\n");
		jsClearActiveCtl;
		return;
	}
}

//------------------------------------------------------------------------------------------------------------//
//	PROC:	jsConnectControlCorners
//	
//		This procedure will make a diagonal connection between the control 
//		and the selected item. 
//------------------------------------------------------------------------------------------------------------//

global proc jsConnectControlCorners(string $position)
{
	//get the name of the control
	string $name =`textField -q -tx jsfWinCurCtlField`; 
	
	
	
	if (`objExists ($name+"Grp")`)
	{
		//get the name of the selected item
		string $selectedName[] = `textScrollList -q -si jsfWinBSTextList`;
		string $selName;
		
		//check if fifty is activated
		int $fifty = 0;
		
		//loop through all the selected names
		for ($selName in $selectedName)
		{
			
			
			//check position
			if (($position == "topRight") && (!$fifty))
			{
				//create clamp node
				string $topRightXClampName = `shadingNode -n ($name+"TopRightXClamp") -asUtility clamp`;
				string $topRightYClampName = `shadingNode -n ($name+"TopRightYClamp") -asUtility clamp`;
				
				string $topRightAddName =`shadingNode -n ($name+"TopRightAdd") -asUtility addDoubleLinear`;
				
				string $topRightMultName = `shadingNode -n ($name+"TopRightMultDivide") -asUtility multiplyDivide`;
				
				//set clamp max and min
				setAttr ($topRightXClampName+".maxR") 1;
				setAttr ($topRightXClampName+".minR") 0;
				setAttr ($topRightYClampName+".maxR") 1;
				setAttr ($topRightYClampName+".minR") 0;
				setAttr ($topRightAddName+".input2") 1;
				
				//connect control to clamp and clamp to blend
				connectAttr -f ($name+"CircleCtrl.tx") ($topRightAddName+".input1");
				connectAttr -f ($topRightAddName+".output") ($topRightXClampName+".inputR");
				
				connectAttr -f ($name+"CircleCtrl.ty") ($topRightYClampName+".inputR");
				
				connectAttr -f ($topRightXClampName+".outputR") ($topRightMultName+".input1X");
				connectAttr -f ($topRightYClampName+".outputR") ($topRightMultName+".input2X");
				
				connectAttr -f ($topRightMultName+".outputX") $selName;
				
				
			}
			//check position
			else if ($position == "bottomRight")
			{
				//create clamp node
				string $bottomRightXClampName = `shadingNode -n ($name+"BottomRightXClamp") -asUtility clamp`;
				string $bottomRightYClampName = `shadingNode -n ($name+"BottomRightYClamp") -asUtility clamp`;
				
				string $bottomRightAddName =`shadingNode -n ($name+"BottomRightAdd") -asUtility addDoubleLinear`;
				
				string $bottomRightMultName = `shadingNode -n ($name+"BottomRightMultDivide") -asUtility multiplyDivide`;
				string $bottomRightYMultName = `shadingNode -n ($name+"BottomRightYMultDivide") -asUtility multiplyDivide`;
				
				//set clamp max and min
				setAttr ($bottomRightXClampName+".maxR") 1;
				setAttr ($bottomRightXClampName+".minR") 0;
				setAttr ($bottomRightYClampName+".maxR") 1;
				setAttr ($bottomRightYClampName+".minR") 0;
				setAttr ($bottomRightAddName+".input2") 1;
				setAttr ($bottomRightYMultName+".input2X") -1;
				
				//connect control to clamp and clamp to blend
				connectAttr -f ($name+"CircleCtrl.tx") ($bottomRightAddName+".input1");
				connectAttr -f ($bottomRightAddName+".output") ($bottomRightXClampName+".inputR");
				
				connectAttr -f ($name+"CircleCtrl.ty") ($bottomRightYMultName+".input1X");
				connectAttr -f ($bottomRightYMultName+".outputX") ($bottomRightYClampName+".inputR");
				
				connectAttr -f ($bottomRightXClampName+".outputR") ($bottomRightMultName+".input1X");
				connectAttr -f ($bottomRightYClampName+".outputR") ($bottomRightMultName+".input2X");
				
				connectAttr -f ($bottomRightMultName+".outputX") $selName;
				
			}
			
			
			//check position
			else if (($position == "topLeft") && (!$fifty))
			{
				//create clamp node
				string $topLeftXClampName = `shadingNode -n ($name+"TopLeftXClamp") -asUtility clamp`;
				string $topLeftYClampName = `shadingNode -n ($name+"TopLeftYClamp") -asUtility clamp`;
				
				string $topLeftXAddName =`shadingNode -n ($name+"TopLeftAdd") -asUtility addDoubleLinear`;
				
				string $topLeftMultName = `shadingNode -n ($name+"TopLeftMultDivide") -asUtility multiplyDivide`;
				string $topLeftXMultName = `shadingNode -n ($name+"TopLeftXMultDivide") -asUtility multiplyDivide`;
				
				//set clamp max and min
				setAttr ($topLeftXClampName+".maxR") 1;
				setAttr ($topLeftXClampName+".minR") 0;
				setAttr ($topLeftYClampName+".maxR") 1;
				setAttr ($topLeftYClampName+".minR") 0;
				setAttr ($topLeftXAddName+".input2") 1;
				setAttr ($topLeftXMultName+".input2X") -1;
				
				//connect control to clamp and clamp to blend
				connectAttr -f ($name+"CircleCtrl.tx") ($topLeftXMultName+".input1X");
				
				connectAttr -f ($topLeftXMultName+".outputX") ($topLeftXAddName+".input1");
				connectAttr -f ($topLeftXAddName+".output") ($topLeftXClampName+".inputR");
				
				connectAttr -f ($name+"CircleCtrl.ty") ($topLeftYClampName+".inputR");
				
				connectAttr -f ($topLeftXClampName+".outputR") ($topLeftMultName+".input1X");
				connectAttr -f ($topLeftYClampName+".outputR") ($topLeftMultName+".input2X");
				
				connectAttr -f ($topLeftMultName+".outputX") $selName;
				
				
			}
			
			//check position
			else if ($position == "bottomLeft")
			{
				//create clamp node
				string $bottomLeftXClampName = `shadingNode -n ($name+"BottomLeftXClamp") -asUtility clamp`;
				string $bottomLeftYClampName = `shadingNode -n ($name+"BottomLeftYClamp") -asUtility clamp`;
				
				string $bottomLeftXAddName =`shadingNode -n ($name+"BottomLeftAdd") -asUtility addDoubleLinear`;
				
				string $bottomLeftMultName = `shadingNode -n ($name+"BottomLeftMultDivide") -asUtility multiplyDivide`;
				string $bottomLeftXMultName = `shadingNode -n ($name+"BottomLeftXMultDivide") -asUtility multiplyDivide`;
				string $bottomLeftYMultName = `shadingNode -n ($name+"BottomLeftYMultDivide") -asUtility multiplyDivide`;
				
				//set clamp max and min
				setAttr ($bottomLeftXClampName+".maxR") 1;
				setAttr ($bottomLeftXClampName+".minR") 0;
				setAttr ($bottomLeftYClampName+".maxR") 1;
				setAttr ($bottomLeftYClampName+".minR") 0;
				setAttr ($bottomLeftXAddName+".input2") 1;
				setAttr ($bottomLeftXMultName+".input2X") -1;
				setAttr ($bottomLeftYMultName+".input2X") -1;
				
				//connect control to clamp and clamp to blend
				connectAttr -f ($name+"CircleCtrl.tx") ($bottomLeftXMultName+".input1X");
				
				connectAttr -f ($bottomLeftXMultName+".outputX") ($bottomLeftXAddName+".input1");
				connectAttr -f ($bottomLeftXAddName+".output") ($bottomLeftXClampName+".inputR");
				
				connectAttr -f ($name+"CircleCtrl.ty") ($bottomLeftYMultName+".input1X");
				connectAttr -f ($bottomLeftYMultName+".outputX") ($bottomLeftYClampName+".inputR");
				
				connectAttr -f ($bottomLeftXClampName+".outputR") ($bottomLeftMultName+".input1X");
				connectAttr -f ($bottomLeftYClampName+".outputR") ($bottomLeftMultName+".input2X");
				
				connectAttr -f ($bottomLeftMultName+".outputX") $selName;
				
				
			}
			
			//this will connect the controls for the fifty control
			else if (($position == "topRight") && ($fifty))
			{
				//create clamp node
				string $topRightXClampName = `shadingNode -n ($name+"TopRightXClamp") -asUtility clamp`;
				string $topRightYClampName = `shadingNode -n ($name+"TopRightYClamp") -asUtility clamp`;
				
				string $topRightAddName =`shadingNode -n ($name+"TopRightAdd") -asUtility addDoubleLinear`;
				
				string $topRightMultName = `shadingNode -n ($name+"TopRightMultDivide") -asUtility multiplyDivide`;
				string $topRightDivName = `shadingNode -n ($name+"TopRightDivide") -asUtility multiplyDivide`;
				
				//set clamp max and min
				setAttr ($topRightXClampName+".maxR") 1;
				setAttr ($topRightXClampName+".minR") 0;
				setAttr ($topRightYClampName+".maxR") 1;
				setAttr ($topRightYClampName+".minR") 0;
				setAttr ($topRightAddName+".input2") 1;
				setAttr ($topRightDivName+".operation") 2;
				setAttr ($topRightDivName+".input2X") 2;
				
				
				//connect control to clamp and clamp to blend
				connectAttr -f ($name+"CircleCtrl.tx") ($topRightAddName+".input1");
				connectAttr -f ($topRightAddName+".output") ($topRightDivName+".input1X");
				connectAttr -f ($topRightDivName+".outputX") ($topRightXClampName+".inputR");
				
				connectAttr -f ($name+"CircleCtrl.ty") ($topRightYClampName+".inputR");
				
				connectAttr -f ($topRightXClampName+".outputR") ($topRightMultName+".input1X");
				connectAttr -f ($topRightYClampName+".outputR") ($topRightMultName+".input2X");
				
				connectAttr -f ($topRightMultName+".outputX") $selName;
				
				
			}
			//this will connect the controls for the fifty control
			else if (($position == "topLeft") && ($fifty))
			{
				//create clamp node
				string $topLeftXClampName = `shadingNode -n ($name+"TopLeftXClamp") -asUtility clamp`;
				string $topLeftYClampName = `shadingNode -n ($name+"TopLeftYClamp") -asUtility clamp`;
				
				string $topLeftAddName =`shadingNode -n ($name+"TopLeftAdd") -asUtility addDoubleLinear`;
				
				string $topLeftMultName = `shadingNode -n ($name+"TopLeftMultDivide") -asUtility multiplyDivide`;
				string $topLeftMultXName = `shadingNode -n ($name+"TopLeftXMultDivide") -asUtility multiplyDivide`;
				string $topLeftDivName = `shadingNode -n ($name+"TopLeftDivide") -asUtility multiplyDivide`;
				
				//set clamp max and min
				setAttr ($topLeftXClampName+".maxR") 1;
				setAttr ($topLeftXClampName+".minR") 0;
				setAttr ($topLeftYClampName+".maxR") 1;
				setAttr ($topLeftYClampName+".minR") 0;
				setAttr ($topLeftAddName+".input2") 1;
				setAttr ($topLeftMultXName+".input2X") -1;
				setAttr ($topLeftDivName+".operation") 2;
				setAttr ($topLeftDivName+".input2X") 2;
				setAttr ($topLeftMultXName+".operation") 1;
				
				
				//connect control to clamp and clamp to blend
				connectAttr -f ($name+"CircleCtrl.tx") ($topLeftMultXName+".input1X");
				connectAttr -f ($topLeftMultXName+".outputX") ($topLeftAddName+".input1");
				connectAttr -f ($topLeftAddName+".output") ($topLeftDivName+".input1X");
				connectAttr -f ($topLeftDivName+".outputX") ($topLeftXClampName+".inputR");
				
				connectAttr -f ($name+"CircleCtrl.ty") ($topLeftYClampName+".inputR");
				
				connectAttr -f ($topLeftXClampName+".outputR") ($topLeftMultName+".input1X");
				connectAttr -f ($topLeftYClampName+".outputR") ($topLeftMultName+".input2X");
				
				connectAttr -f ($topLeftMultName+".outputX") $selName;
				
			}
			//print that it was succesful
			print ("connection succesfully made!\n");
		
		}
	}
	
	else if (!`objExists ($name+"Grp")`) {
		warning ("No control named "+$name+" exists. Please update the active control!\n");
		jsClearActiveCtl;
		return;
	}
}


global proc jsUpdate() {
//updates the active control based on the selected object

	//get the name of the selected object
	string $sel[] = `ls -sl`;
	
	//check to see if anything is selected
	if (size($sel)!= 1) {
		warning "please only select one control";
		return;
	} else {
		//get a list of attributes
		string $attrs[] = `listAttr`;
		string $attr;
		
		//loop through all the attributes to check if it's a valid control
		for ($attr in $attrs)
		{
			if ($attr == "name")
			{
				//get the attribute string that holds the name
				$name = `getAttr ($sel[0]+".name")`;
			
		
				//set the textField
				textField -e -tx $name jsfWinCurCtlField;				
				jsCheckControlType;
			}
		}
	}
	
}
	
	
global proc jsCheckControlType() {
//hides buttons that are not applicable to the current ctl
	//get the name of the active control
	string $name = `textField -q -tx jsfWinCurCtlField`;
	
	//if the object doesnt exist print this error
	if (!`objExists ($name+"Grp")`)
		error "Control does not exist\n";
	
	//get the attribute type for the active control
	string $type = `getAttr ($name+"Grp.type")`;
	
	//btn list contains the numbers of buttons corresponding to each controls type
	string $btnListA[] = {"2", "7"};
	string $btnListB[] = {"4", "5"};
	string $btnListC[] = {"1", "2", "3", "4", "5", "6", "7", "8"};
	string $btnListD[] = {"1", "2", "3", "4", "5"};
	string $btnListE[] = {"2", "3", "5"};
	string $btnListFa[] = {"2"};
	string $btnListFb[] = {"5"};
	string $btnList50[] = {"1", "3"};
	
	//the right list will be stored to this array
	string $useList[];
	
	//hide all the buttons (use listC to get all the buttons)
	for ($letter in $btnListC) {
		button -e -vis 0 ("jsfWinConnectBtn"+$letter);
	}
	
	//show the right ones
	if ($type == "A")
		$useList = $btnListA;
	if ($type == "B")
		$useList = $btnListB;
	if ($type == "C")
		$useList = $btnListC;
	if ($type == "D")
		$useList = $btnListD;
	if ($type == "E")
		$useList = $btnListE;
	if ($type == "Fa")
		$useList = $btnListFa;
	if ($type == "Fb")
		$useList = $btnListFb;
	if ($type == "50")
		$useList = $btnList50;
	
	
	
	for ($letter in $useList) {
		button -e -vis 1 ("jsfWinConnectBtn"+$letter);
	}
}
global proc jsClearActiveCtl () {
	//clear the text field
	textField -e -tx "" jsfWinCurCtlField;
	//clear all the buttons
	string $btnList[] = {"1", "2", "3", "4", "5", "6", "7", "8"};
	for ($letter in $btnList) {
		button -e -vis 0 ("jsfWinConnectBtn"+$letter);
	}
}
